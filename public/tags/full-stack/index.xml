<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
	<title>Amans Place</title>
	<link>http://localhost:1313/tags/full-stack/</link>
	<description>Recent content in Full-Stack on Amans Place</description>
	<generator>Hugo -- gohugo.io</generator>
	<language>en-us</language>
	<lastBuildDate>Wed, 22 Jan 2025 16:45:00 -0500</lastBuildDate>
    
        <atom:link href="http://localhost:1313/tags/full-stack/index.xml" rel="self" type="application/rss+xml" />
	
	
	<item>
		<title>Building My First Full-Stack App: Lessons from the Trenches</title>
		<link>http://localhost:1313/blog/first-fullstack-app/</link>
		<pubDate>Wed, 22 Jan 2025 16:45:00 -0500</pubDate>
		
		<guid>http://localhost:1313/blog/first-fullstack-app/</guid>
		<description>&lt;h1 id=&#34;building-my-first-full-stack-app-lessons-from-the-trenches&#34;&gt;Building My First Full-Stack App: Lessons from the Trenches&lt;/h1&gt;
&lt;p&gt;Three months ago, I decided to build a proper full-stack application from scratch. Not a tutorial project, not a clone—something original that solved a real problem. It was harder than I expected, but the learning was incredible.&lt;/p&gt;
&lt;h2 id=&#34;the-project-tasksync&#34;&gt;The Project: TaskSync&lt;/h2&gt;
&lt;p&gt;A collaborative task management app with real-time updates. Users can create projects, assign tasks, and see changes instantly across all connected clients. Simple concept, complex execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tech Stack:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frontend: React with TypeScript&lt;/li&gt;
&lt;li&gt;Backend: Node.js with Express&lt;/li&gt;
&lt;li&gt;Database: PostgreSQL with Prisma ORM&lt;/li&gt;
&lt;li&gt;Real-time: Socket.io&lt;/li&gt;
&lt;li&gt;Deployment: Vercel (frontend) + Railway (backend)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;week-1-overconfidence&#34;&gt;Week 1: Overconfidence&lt;/h2&gt;
&lt;p&gt;I thought I had this figured out. &amp;ldquo;I know React, I&amp;rsquo;ve built APIs, how hard can it be?&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reality check:&lt;/strong&gt; Connecting a frontend to a backend involves a thousand small decisions. How do you handle authentication tokens? What about loading states? Error boundaries? CORS configuration?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First major mistake:&lt;/strong&gt; Starting without a clear data model. I spent days refactoring database schemas because I didn&amp;rsquo;t think through the relationships between users, projects, and tasks upfront.&lt;/p&gt;
&lt;h2 id=&#34;week-2-3-the-authentication-nightmare&#34;&gt;Week 2-3: The Authentication Nightmare&lt;/h2&gt;
&lt;p&gt;Authentication is where tutorial projects diverge from real applications. JWT tokens, refresh tokens, secure cookie storage, password hashing—each piece seems simple until you try to make them work together.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What worked:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using bcrypt for password hashing&lt;/li&gt;
&lt;li&gt;Storing JWT tokens in httpOnly cookies&lt;/li&gt;
&lt;li&gt;Implementing middleware for protected routes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;What didn&amp;rsquo;t:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trying to roll my own session management&lt;/li&gt;
&lt;li&gt;Not planning for token expiration from the start&lt;/li&gt;
&lt;li&gt;Forgetting about password reset functionality&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;week-4-5-real-time-reality&#34;&gt;Week 4-5: Real-time Reality&lt;/h2&gt;
&lt;p&gt;Socket.io looked simple in the docs. In practice, managing real-time state synchronization is mind-bending.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Challenges I didn&amp;rsquo;t expect:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handling users who disconnect and reconnect&lt;/li&gt;
&lt;li&gt;Preventing infinite update loops&lt;/li&gt;
&lt;li&gt;Optimistic updates vs. server confirmation&lt;/li&gt;
&lt;li&gt;Memory leaks from uncleaned event listeners&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt; Keep real-time updates simple. Don&amp;rsquo;t try to sync entire application state—just broadcast specific events and let clients refetch data when needed.&lt;/p&gt;
&lt;h2 id=&#34;week-6-8-polish-and-performance&#34;&gt;Week 6-8: Polish and Performance&lt;/h2&gt;
&lt;p&gt;The last 20% took 50% of the time. Error handling, loading states, responsive design, input validation, and deployment configuration.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Performance lessons:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Database indexes matter more than I thought&lt;/li&gt;
&lt;li&gt;N+1 queries kill performance (learned this the hard way)&lt;/li&gt;
&lt;li&gt;Image optimization is non-negotiable&lt;/li&gt;
&lt;li&gt;Bundle size affects user experience on mobile&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;week-9-10-deployment-hell&#34;&gt;Week 9-10: Deployment Hell&lt;/h2&gt;
&lt;p&gt;Local development is comfortable. Production is ruthless.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Environment variable management&lt;/strong&gt; across different platforms is surprisingly complex. What works on Vercel doesn&amp;rsquo;t necessarily work on Railway.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CORS issues&lt;/strong&gt; that didn&amp;rsquo;t exist in development suddenly appeared in production.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Database migrations&lt;/strong&gt; required careful planning—you can&amp;rsquo;t just drop tables in production.&lt;/p&gt;
&lt;h2 id=&#34;what-id-do-differently&#34;&gt;What I&amp;rsquo;d Do Differently&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Plan the data model first&lt;/strong&gt; - Draw it out, think through relationships&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set up deployment early&lt;/strong&gt; - Don&amp;rsquo;t wait until the end&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Add logging and monitoring from day one&lt;/strong&gt; - You can&amp;rsquo;t debug what you can&amp;rsquo;t see&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write tests for critical paths&lt;/strong&gt; - Authentication and data consistency especially&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use established patterns&lt;/strong&gt; - Don&amp;rsquo;t reinvent authentication or state management&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;what-i-learned&#34;&gt;What I Learned&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Full-stack development is system thinking.&lt;/strong&gt; It&amp;rsquo;s not just about knowing React and Node.js—it&amp;rsquo;s about understanding how all the pieces interact.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The devil is in the integration.&lt;/strong&gt; Individual technologies are well-documented. Making them work together requires experience and patience.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ship early, iterate fast.&lt;/strong&gt; My first version was embarrassingly basic, but getting real user feedback was more valuable than perfect code.&lt;/p&gt;
&lt;h2 id=&#34;the-result&#34;&gt;The Result&lt;/h2&gt;
&lt;p&gt;TaskSync is live and being used by my study group to manage our learning projects. It&amp;rsquo;s not going to compete with Notion or Asana, but it works, it&amp;rsquo;s fast, and I built it myself.&lt;/p&gt;
&lt;p&gt;More importantly, I now understand what &amp;ldquo;full-stack developer&amp;rdquo; actually means. It&amp;rsquo;s not about knowing every technology—it&amp;rsquo;s about understanding how to connect technologies to solve real problems.&lt;/p&gt;
&lt;p&gt;The next project will be easier. The one after that even more so. That&amp;rsquo;s how you build expertise: one frustrating bug at a time.&lt;/p&gt;
</description>
	</item>
	
	</channel>
</rss>
